I have been thinking about how common graph traversal algorithms could implemented in Rust.  So I decided to find some graph traversal problems on https://www.leetcode.com[leetcode].  I found a nice https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/[simple problem] that I decided to solve.

A linear algorithm for this problem would require post order traversal of the graph.  Essentially, at each node (N), we would first figure out the following three bits of information.
- Sum of the subtree rooted at node which is computed as the sum of the subtree rooted at the two children plus the value of the node.
- Number of nodes in the subtree rooted at node which is computed as the sum of number of nodes at the two children plus one.
- Number of nodes in the subtree rooted at node that fullfil the requirements of the question which is computed as the sum of the nodes that fullfil the requirements of the question at the two children plus one if the current node also fullfils it.

As is sometimes the case, implementing the algorithm using recursion is easier so that was my first attempt.

`
use std::cell::RefCell;
use std::rc::Rc;

fn get_avg(root: Option<Rc<RefCell<TreeNode>>>) -> (i32, i32, i32) {
    match root {
        None => (0, 0, 0),
        Some(node) => {
            let node = node.borrow();
            let (left_total, left_nodes, left_avg) = get_avg(node.left.clone());
            let (right_total, right_nodes, right_avg) = get_avg(node.right.clone());
            let total = left_total + right_total + node.val;
            let nodes = left_nodes + right_nodes + 1;
            let mut avg = left_avg + right_avg;
            if total / nodes == node.val {
                avg += 1;
            }
            (total, nodes, avg)
        }
    }
}

impl Solution {
    pub fn average_of_subtree(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {
        let (_, _, avg) = get_avg(root);
        avg
    }
}
`

A recursive implementation can be risky for very deep trees, as we will have a lot of stack frames and potentially run out of stack space.  An iterative approach is sometimes preferable in such cases.  Before I show the iterative solution in Rust, I think it is worth looking at an interative solution in Python.  I show this solution because I was unable to implement it in Rust due to some the restrictions that the language has and I had to come up with another approach.

`
use std::cell::RefCell;
use std::rc::Rc;

impl Solution {
    pub fn average_of_subtree(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {
        let mut results = vec![];
        let mut stack0 = vec![(root, None)];
        let mut stack1 = vec![];
        while let Some((node, parent_ind)) = stack0.pop() {
            match node {
                None => (),
                Some(node) => {
                    {
                        let node = node.borrow();
                        stack0.push((node.right.clone(), Some(results.len())));
                        stack0.push((node.left.clone(), Some(results.len())));
                    }
                    stack1.push((node, results.len(), parent_ind));
                    results.push((0, 0, 0));
                }
            }
        }
        while let Some((node, my_ind, parent_ind)) = stack1.pop() {
            let (mut total, mut nodes, mut avg) = results[my_ind];
            let node = node.borrow();
            total += node.val;
            nodes += 1;
            if total / nodes == node.val {
                avg += 1;
            }
            match parent_ind {
                None => results[my_ind] = (total, nodes, avg),
                Some(parent_ind) => {
                    let (mut ptotal, mut pnodes, mut pavg) = results[parent_ind];
                    ptotal += total;
                    pnodes += nodes;
                    pavg += avg;
                    results[parent_ind] = (ptotal, pnodes, pavg)
                }
            }
        }
        results[0].2
    }
}
`
